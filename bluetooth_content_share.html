<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body>def removeLeftRecursion(rulesDiction):<br>	<br>	store = {}<br>	for lhs in rulesDiction:<br>		alphaRules = []<br>		betaRules = []<br>		allrhs = rulesDiction[lhs]<br>		for subrhs in allrhs:<br>			if subrhs[0] == lhs:<br>				<a href="http://alphaRules.append">alphaRules.append</a>(subrhs[1:])<br>			else:<br>				<a href="http://betaRules.append">betaRules.append</a>(subrhs)<br>		if len(alphaRules) != 0:<br>			lhs_ = lhs + "'"<br>			while (lhs_ in <a href="http://rulesDiction.keys">rulesDiction.keys</a>()) \<br>					or (lhs_ in <a href="http://store.keys">store.keys</a>()):<br>				lhs_ += "'"<br>			for b in range(0, len(betaRules)):<br>				betaRules[b].append(lhs_)<br>			rulesDiction[lhs] = betaRules<br>			for a in range(0, len(alphaRules)):<br>				alphaRules[a].append(lhs_)<br>			<a href="http://alphaRules.append">alphaRules.append</a>(['#'])<br>			store[lhs_] = alphaRules<br>	for left in store:<br>		rulesDiction[left] = store[left]<br>	return rulesDiction<br><br><br>def LeftFactoring(rulesDiction):<br>	newDict = {}<br>	for lhs in rulesDiction:<br>		allrhs = rulesDiction[lhs]<br>		temp = dict()<br>		for subrhs in allrhs:<br>			if subrhs[0] not in list(<a href="http://temp.keys">temp.keys</a>()):<br>				temp[subrhs[0]] = [subrhs]<br>			else:<br>				temp[subrhs[0]].append(subrhs)<br>		new_rule = []<br>		tempo_dict = {}<br>		for term_key in temp:<br>			allStartingWithTermKey = temp[term_key]<br>			if len(allStartingWithTermKey) &gt; 1:<br>				lhs_ = lhs + "'"<br>				while (lhs_ in <a href="http://rulesDiction.keys">rulesDiction.keys</a>()) \<br>						or (lhs_ in <a href="http://tempo_dict.keys">tempo_dict.keys</a>()):<br>					lhs_ += "'"<br>				<a href="http://new_rule.append">new_rule.append</a>([term_key, lhs_])<br>				ex_rules = []<br>				for g in temp[term_key]:<br>					<a href="http://ex_rules.append">ex_rules.append</a>(g[1:])<br>				tempo_dict[lhs_] = ex_rules<br>			else:<br>				<a href="http://new_rule.append">new_rule.append</a>(allStartingWithTermKey[0])<br>		newDict[lhs] = new_rule<br>		for key in tempo_dict:<br>			newDict[key] = tempo_dict[key]<br>	return newDict<br><br><br>def first(rule):<br>	global rules, nonterm_userdef, \<br>		term_userdef, diction, firsts<br>	if len(rule) != 0 and (rule is not None):<br>		if rule[0] in term_userdef:<br>			return rule[0]<br>		elif rule[0] == '#':<br>			return '#'<br><br>	if len(rule) != 0:<br>		if rule[0] in list(<a href="http://diction.keys">diction.keys</a>()):<br>			fres = []<br>			rhs_rules = diction[rule[0]]<br>			for itr in rhs_rules:<br>				indivRes = first(itr)<br>				if type(indivRes) is list:<br>					for i in indivRes:<br>						<a href="http://fres.append">fres.append</a>(i)<br>				else:<br>					<a href="http://fres.append">fres.append</a>(indivRes)<br><br>			if '#' not in fres:<br>				return fres<br>			else:<br>				newList = []<br>				<a href="http://fres.remove">fres.remove</a>('#')<br>				if len(rule) &gt; 1:<br>					ansNew = first(rule[1:])<br>					if ansNew != None:<br>						if type(ansNew) is list:<br>							newList = fres + ansNew<br>						else:<br>							newList = fres + [ansNew]<br>					else:<br>						newList = fres<br>					return newList<br>				<a href="http://fres.append">fres.append</a>('#')<br>				return fres<br><br><br>def follow(nt):<br>	global start_symbol, rules, nonterm_userdef, \<br>		term_userdef, diction, firsts, follows<br><br>	solset = set()<br>	if nt == start_symbol:<br>		<a href="http://solset.add">solset.add</a>('$')<br><br>	for curNT in diction:<br>		rhs = diction[curNT]<br>		for subrule in rhs:<br>			if nt in subrule:<br>				while nt in subrule:<br>					index_nt = <a href="http://subrule.index">subrule.index</a>(nt)<br>					subrule = subrule[index_nt + 1:]<br>					if len(subrule) != 0:<br>						res = first(subrule)<br>						if '#' in res:<br>							newList = []<br>							<a href="http://res.remove">res.remove</a>('#')<br>							ansNew = follow(curNT)<br>							if ansNew != None:<br>								if type(ansNew) is list:<br>									newList = res + ansNew<br>								else:<br>									newList = res + [ansNew]<br>							else:<br>								newList = res<br>							res = newList<br>					else:<br>						if nt != curNT:<br>							res = follow(curNT)<br><br>					if res is not None:<br>						if type(res) is list:<br>							for g in res:<br>								<a href="http://solset.add">solset.add</a>(g)<br>						else:<br>							<a href="http://solset.add">solset.add</a>(res)<br>	return list(solset)<br><br><br>def computeAllFirsts():<br>	global rules, nonterm_userdef, \<br>		term_userdef, diction, firsts<br>	for rule in rules:<br>		k = <a href="http://rule.split">rule.split</a>("-&gt;")<br>		k[0] = k[0].strip()<br>		k[1] = k[1].strip()<br>		rhs = k[1]<br>		multirhs = <a href="http://rhs.split">rhs.split</a>('|')<br>		for i in range(len(multirhs)):<br>			multirhs[i] = multirhs[i].strip()<br>			multirhs[i] = multirhs[i].split()<br>		diction[k[0]] = multirhs<br><br>	print(f"\nRules: \n")<br>	for y in diction:<br>		print(f"{y}-&gt;{diction[y]}")<br>	print(f"\nAfter elimination of left recursion:\n")<br><br>	diction = removeLeftRecursion(diction)<br>	for y in diction:<br>		print(f"{y}-&gt;{diction[y]}")<br>	print("\nAfter left factoring:\n")<br><br>	diction = LeftFactoring(diction)<br>	for y in diction:<br>		print(f"{y}-&gt;{diction[y]}")<br><br>	for y in list(<a href="http://diction.keys">diction.keys</a>()):<br>		t = set()<br>		for sub in <a href="http://diction.get">diction.get</a>(y):<br>			res = first(sub)<br>			if res != None:<br>				if type(res) is list:<br>					for u in res:<br>						<a href="http://t.add">t.add</a>(u)<br>				else:<br>					<a href="http://t.add">t.add</a>(res)<br><br>		firsts[y] = t<br><br>	print("\nCalculated firsts: ")<br>	key_list = list(<a href="http://firsts.keys">firsts.keys</a>())<br>	index = 0<br>	for gg in firsts:<br>		print(f"first({key_list[index]}) "<br>			f"=&gt; {<a href="http://firsts.get">firsts.get</a>(gg)}")<br>		index += 1<br><br><br>def computeAllFollows():<br>	global start_symbol, rules, nonterm_userdef,\<br>		term_userdef, diction, firsts, follows<br>	for NT in diction:<br>		solset = set()<br>		sol = follow(NT)<br>		if sol is not None:<br>			for g in sol:<br>				<a href="http://solset.add">solset.add</a>(g)<br>		follows[NT] = solset<br><br>	print("\nCalculated follows: ")<br>	key_list = list(<a href="http://follows.keys">follows.keys</a>())<br>	index = 0<br>	for gg in follows:<br>		print(f"follow({key_list[index]})"<br>			f" =&gt; {follows[gg]}")<br>		index += 1<br><br>sample_input_string = None<br><br>rules=["S -&gt; A k O",<br>	"A -&gt; A d | a B | a C",<br>	"C -&gt; c",<br>	"B -&gt; b B C | r"]<br><br>nonterm_userdef=['A','B','C']<br>term_userdef=['k','O','d','a','c','b','r']<br>sample_input_string="a r k O"<br><br>diction = {}<br>firsts = {}<br>follows = {}<br><br>computeAllFirsts()<br><br>start_symbol = list(<a href="http://diction.keys">diction.keys</a>())[0]<br><br>computeAllFollows()</body></html>